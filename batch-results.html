<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batch Results</title>
    <link rel="stylesheet" href="styles/15_batch-results.css"> <!-- Link to the same CSS file -->
    <link rel="stylesheet" href="styles/02_top-toolbar.css">
    <link rel="stylesheet" href="styles/01_search-bar.css">
</head>

<aside id="disclaimer">
    *NONE OF THE DATA ON THIS SITE IS REAL AND IS ONLY USED AS A DEMONSTRATION OF HOW THE SITE WORKS*
</aside>

<body>
    <header>
        <a href="index.html" id="logo">Alpha-Ionix</a>
        <!-- Navigation Toolbar -->
        <nav>
            <ul>
                <!-- Login Dropdown -->
                <li><a href="#" id="login-btn">Login</a>
                    <ul id="dropdown-menu" class="hidden">
                        <li><a href="sample-login.html">Sample Login</a></li>
                    </ul>
                </li>

                <!-- Analysis Dropdown -->
                <li><a href="#" id="login-btn">Analysis</a>
                    <ul id="dropdown-menu" class="hidden">
                        <li><a href="batches.html">Batches</a></li>
                        <li><a href="samples.html">Samples</a></li>
                        <li><a href="workorders.html">Workorders</a></li>
                    </ul>
                </li>

                <!-- Attributes Dropdown -->
                <li><a href="#" id="login-btn">Sample Attributes</a>
                    <ul id="dropdown-menu" class="hidden">
                        <li><a href="benchsheets.html">BenchSheets</a></li>
                        <li><a href="container-types.html">Containers</a></li>
                        <li><a href="equipment.html">Equipment</a></li>
                        <li><a href="hold-time.html">Hold Times</a></li>
                        <li><a href="matrix-types.html">Matrix Types</a></li>
                        <li><a href="reports.html">Reports</a></li>
                        <li><a href="sample-types.html">Sample Types</a></li>
                        <li><a href="standards.html">Standards</a></li>
                        <li><a href="test-code-table.html">Test Codes</a></li>
                        <li><a href="qualifiers.html">Qualifiers</a></li>
                        <li><a href="condition-codes.html">Condition Codes</a></li>
                    </ul>
                </li>

                <!-- Clients Dropdown -->
                <li><a href="#" id="clients-btn">Clients</a>
                    <ul id="dropdown-menu" class="hidden">
                        <li><a href="client-by-name.html">Client by Name</a></li>
                        <li><a href="client-by-site.html">Client by Site</a></li>
                        <li><a href="client-profile.html">Client Profiles</a></li>
                    </ul>
                </li>
    
                <!-- Users Dropdown -->
                <li><a href="#" id="settings-btn">Settings</a>
                    <ul id="dropdown-menu" class="hidden">
                        <li><a href="account-settings.html">Account Settings</a></li>
                        <li><a href="app-settings.html">Application Settings</a></li>
                        <li><a href="users.html">Users</a></li>
                        <li><a href="user-role-management.html">Roles</a></li>
                        <li><a href="help.html">Help</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
    </header>

    <aside id="toolbar">
        <ul>
            <li><a href="compliance.html">Compliance</a></li>
            <li><a href="chemicials.html">Chemicals</a></li>
            <li><a href="procedures.html">Procedures</a></li> 
        </ul>
        <!-- Search Bar -->
<div id="search-container">
    <input type="text" id="search-bar" placeholder="Search..." />
    <button id="search-button">üîç</button>
</div>
    </aside>

    <main>
        <h2>Batch Results
            <div class="dropdown">
                <button class="dropdown-button">Actions</button>
                <div class="dropdown-content">
                    <a href="#" id="view-results">Sample Results</a>
                    <a href="#" id="view-qc">QC Results</a>
                </div>
            </div>
        </h2>
        <section id="batch-results-container">
            <h3>Batch Information
                <button id="complete-review-button">Complete Review</button>
            </h3>
            <!-- Results Form -->
            <div id="batch-info-container">
                <p><strong>Batch ID:</strong> <span id="batch-id"></span></p>
                <p><strong>Analysis:</strong> <span id="analysis"></span></p>
                <p><strong>Date Created:</strong> <span id="date-created"></span></p>
                <p><strong>Number of Samples:</strong> <span id="number-of-samples"></span></p>
                <p><strong>Status:</strong> <span id="status"></span></p>
            </div>            
            <h3>
                <span>Sample Results</span>
                <div class="button-container">
                <!-- Buttons -->
                <button id="submit-results-button">Submit Results</button>
                <button id="save-results-button">Save</button>
                </div>
            </h3>
            <table id="samples-results-table">
                <thead>
                    <th></th>
                    <th>Sample ID</th>
                    <th>Sample Type</th>
                    <th>Analyst</th>
                    <th>Instrument</th>
                    <th>Run Date</th>
                    <th>Spiked?</th>
                    <th>Dilute First?</th>
                    <th>Standard ID</th>
                    <th>Spiked Volume</th>
                    <th>Spiked Units</th>
                    <th>Comments</th>
                </thead>                             
                <tbody>
                    <!-- Dynamically populated -->
                </tbody>
            </table>            
        </section>
    </main>

    <div id="qc-results-modal-table-container" class="modal">
        <div class="modal-content">
            <h3>QC Result Details</h3>
            <table id="qc-results-modal-table">
                <thead>
                    <!-- Dynamically populated -->
                </thead>
                <tbody>
                    <!-- Dynamically populated -->
                </tbody>
            </table>
            <button id="close-btn">Close</button> <!-- Close button -->
        </div>
    </div>    

    <script>
window.onload = async function () {
    const urlParams = new URLSearchParams(window.location.search);
    const batchId = urlParams.get("batchId");
    const completeReviewButton = document.querySelector("#complete-review-button");

    if (!batchId) {
        alert("Batch ID is missing!");
        window.location.href = "batches.html";
        return;
    }

    // Retrieve batch details from localStorage
    const batches = JSON.parse = await localforage.getItem("batches") || [];
    const batch = batches.find((b) => b.batchId === batchId);

    if (batch) {
    // Display batch details
    const batchIdElement = document.getElementById("batch-id");
    batchIdElement.innerHTML = `<a href="batch-details.html?batchId=${batch.batchId}" style="text-decoration: none; color: inherit;">${batch.batchId}</a>`; // Make it a clickable link
    
    document.getElementById("analysis").textContent = batch.analysis;
    document.getElementById("date-created").textContent = batch.createdDate;
    document.getElementById("number-of-samples").textContent = batch.numberOfSamples; // Added
    document.getElementById("status").textContent = batch.status; // Added
    
        // Display sample results table
        const samples = JSON.parse = await localforage.getItem("sampleDataArray") || [];
        const associatedSamples = samples.filter(sample => sample.batchId === batchId);
        const resultsTableBody = document.querySelector("#samples-results-table tbody");

        // Load previously saved results for the current batch
        const savedResultsKey = `savedBatchResults-${batchId}`;
        const savedResults = JSON.parse = await localforage.getItem(savedResultsKey) || {};

        // **Retrieve Analyst Initials from localStorage**
        const analystInitials = JSON.parse = await localforage.getItem("analystInitials") || [];

        // **Retrieve instrument names from localStorage**
        const instrumentNames = JSON.parse = await localforage.getItem("instrumentNames") || [];

        // **Retrieve Qualifiers names from localStorage**
        const qualifiers = JSON.parse = await localforage.getItem("qualifiers") || [];

        const standards = JSON.parse = await localforage.getItem('standards') || [];

        // **Get the correct test code based on batch analysis**
        const testCodes = JSON.parse = await localforage.getItem("testCodes") || [];
        const matchedTestCode = testCodes.find(tc => tc.analysisId === batch.analysis);

        // **Retrieve the corresponding test code details**
        let analyteDetailsMap = {};
        if (matchedTestCode) {
            const testCodeDetails = JSON.parse = await localforage.getItem("testCodes") || [];
            const matchedDetails = testCodeDetails.find(tc => tc.uniqueId === matchedTestCode.uniqueId);

            if (matchedDetails) {
            // ‚úÖ FIX: Extract Units from Analytes tab
            if (matchedDetails.analytes) {
                matchedDetails.analytes.forEach(analyte => {
                    if (!analyteDetailsMap[analyte.analyteName]) {
                        analyteDetailsMap[analyte.analyteName] = {
                            units: analyte.units || "",
                            initialVolume: analyte.initialVolume || "",
                            finalVolume: analyte.finalVolume || "",
                            mdl: "",
                            loq: ""
                        };
                    }
                });
            }

            // ‚úÖ FIX: Extract MDL & LOQ from Method Blank Tab
            const methodBlankTab = matchedDetails.qcTabs.find(tab => tab.tabName === "Method Blank");

            if (methodBlankTab && methodBlankTab.rows) {
                methodBlankTab.rows.forEach(row => {
                    if (analyteDetailsMap[row.analyteName]) {
                        analyteDetailsMap[row.analyteName].mdl = row.mdl || "";
                        analyteDetailsMap[row.analyteName].loq = row.loq || "";
                    }
                });
            }
        }
    }

    associatedSamples.forEach((sample, index) => {
    // Insert the repeated header row, but skip it for the first row (index 0)
    if (index !== 0) {
    const repeatedHeaderRow = document.createElement("tr");
    repeatedHeaderRow.classList.add("repeated-header-row", `header-row-${sample.id}`);
    repeatedHeaderRow.style.display = "none";  // Hide by default
    repeatedHeaderRow.innerHTML = `
        <th></th> <!-- Expansion button column -->
        <th>Sample ID</th>
        <th>Sample Type</th>
        <th>Analyst</th>
        <th>Instrument</th>
        <th>Run Date</th>
        <th>Spiked?</th>
        <th>Diluted First?</th>
        <th>Standard ID</th>
        <th>Spiked Volume</th>
        <th>Spiked Units</th>
        <th>Comments</th>
    `;
    resultsTableBody.appendChild(repeatedHeaderRow);
    }

    // Load saved results or use defaults
    const sampleResults = savedResults[sample.id] || {};

    // Main sample row
    const mainRow = document.createElement("tr");
    mainRow.classList.add("sample-row");
    mainRow.innerHTML = `
        <td>
            <button class="expand-btn" data-sample-id="${sample.id}">‚ñ∂</button>
        </td>
        <td><a href="sample-details.html?id=${sample.id}">${sample.id}</a></td>
        <td>${sample.sampleType}</td>
        <td>
            <select name="analyst-${sample.id}">
                ${getAnalystOptions(sampleResults.analyst || "")}
            </select>
        </td>
        <td>
            <select name="instrument-${sample.id}">
                ${getInstrumentOptions(sampleResults.instrument || "")}
            </select>
        </td>
        <td><input type="date" name="run-date-${sample.id}" value="${sampleResults.runDate || ""}" /></td>
        <td>
        <select name="spiked-${sample.id}">
            <option value="No" ${sampleResults.spiked === false ? 'selected' : ''}>No</option>
            <option value="Yes" ${sampleResults.spiked === true ? 'selected' : ''}>Yes</option>
        </select>
        </td>
        <td>
            <select name="diluted-first-${sample.id}">
                <option value="No" ${sampleResults.dilutedFirst === false ? 'selected' : ''}>No</option>
                <option value="Yes" ${sampleResults.dilutedFirst === true ? 'selected' : ''}>Yes</option>
            </select>
        </td>
        <td>
            <select name="standard-id-${sample.id}">
                ${getStandardOptions(sampleResults.standard || "")}
            </select>
        </td>
        <td><input type="text" name="spiked-amount-${sample.id}" value="${sampleResults.spikedAmount || ''}" placeholder="Spiked Volume" /></td> <!-- New -->
        <td><input type="text" name="spiked-units-${sample.id}" value="${sampleResults.spikedUnits || ''}" placeholder="Spiked Units" /></td> <!-- New -->
        <td><input type="text" name="sample-comments-${sample.id}" value="${sampleResults.comments || ""}" placeholder="Sample Comments" /></td>
    `;
    resultsTableBody.appendChild(mainRow);

    // Sub-row header
    const subRowHeader = document.createElement("tr");
    subRowHeader.classList.add(`sub-header-${sample.id}`, "sub-row-header");
    subRowHeader.style.display = "none"; // Initially hidden
    subRowHeader.innerHTML = `
        <td></td>
        <td>Analyte</td>
        <td>Condition</td>
        <td>Raw Result</td>
        <td>Units</td>
        <td>MDL</td>
        <td>LOQ</td>
        <td>Initial Volume</td>
        <td>Final Volume</td>
        <td>Post Prep Dil</td>
        <td>Data Qualifier</td>
        <td>Comments</td>
    `;
    resultsTableBody.appendChild(subRowHeader);

    // Sub-rows for each analyte
    const analytes = sample.analytes || [];
    analytes.forEach((analyte, index) => {
        const analyteResult = sampleResults.analytes?.[index] || {};
        const analyteInfo = analyteDetailsMap[analyte] || { units: "", mdl: "", loq: "" };

        const analyteRow = document.createElement("tr");
        analyteRow.classList.add("analyte-row", `analyte-row-${sample.id}`);
        analyteRow.style.display = "none"; // Initially hidden
        analyteRow.innerHTML = `
            <td></td>
            <td>${analyte}</td>
            <td>
                <select name="condition-${sample.id}-${index}">
                    ${getConditionOptions(analyteResult.condition || "")}
                </select>
            </td>
            <td><input type="text" name="result-${sample.id}-${index}" value="${analyteResult.result || ""}" placeholder="Result" /></td>
            <td><input type="text" name="units-${sample.id}-${index}" value="${analyteInfo.units}" readonly /></td>
            <td><input type="text" name="mdl-${sample.id}-${index}" value="${analyteInfo.mdl}" readonly /></td>
            <td><input type="text" name="loq-${sample.id}-${index}" value="${analyteInfo.loq}" readonly /></td>
            <td><input type="text" name="initial-volume-${sample.id}-${index}" value="${analyteResult.initialVolume || analyteInfo.initialVolume || ""}" /></td>
            <td><input type="text" name="final-volume-${sample.id}-${index}" value="${analyteResult.finalVolume || analyteInfo.finalVolume || ""}" /></td>
            <td><input type="number" name="dilution-${sample.id}-${index}" value="${analyteResult.dilution || "1"}" placeholder="Dilution" /></td>
            <td>
                <select name="qualifier-${sample.id}-${index}">
                    ${getQualifierOptions(analyteResult.qualifier || "")}
                </select>
            </td>
            <td><input type="text" name="comments-${sample.id}-${index}" value="${analyteResult.comments || ""}" placeholder="Analyte Comments" /></td>
        `;
        resultsTableBody.appendChild(analyteRow);
    });

            // Add an empty row after the last analyte-row
            if (analytes.length > 0) {
                const spacerRow = document.createElement("tr");
                spacerRow.classList.add("spacer-row");
                spacerRow.innerHTML = `<td colspan="12" style="height: 5px; border: none;"></td>`;
                resultsTableBody.appendChild(spacerRow);
            }

            async function getConditionOptions(selectedCondition) {
            const conditionCodes = JSON.parse = await localforage.getItem('conditionCodes') || [];
            let options = '<option value="">Select Condition</option>'; // Default option

            // Add the "OK" option and make it selected by default if nothing else is selected
            const isOkSelected = !selectedCondition || selectedCondition === 'OK' ? 'selected' : '';
            options += `<option value="OK" ${isOkSelected}>OK</option>`;

            conditionCodes.forEach((code) => {
                const isSelected = code.conditionCode === selectedCondition ? 'selected' : '';
                options += `<option value="${code.conditionCode}" ${isSelected}>${code.conditionCode}</option>`;
            });
            return options;
            }

            async function getInstrumentOptions(selectedInstrument) {
                let options = '<option value="">Select Instrument</option>'; // Default option
                instrumentNames.forEach(instrument => {
                    const isSelected = instrument === selectedInstrument ? 'selected' : '';
                    options += `<option value="${instrument}" ${isSelected}>${instrument}</option>`;
                });
                return options;
            }

            async function getAnalystOptions(selectedAnalyst) {
            const analystInitials = JSON.parse = await localforage.getItem("analystInitials") || [];
            let options = '<option value="">Select Analyst</option>'; // Default option
            analystInitials.forEach(initials => {
                const isSelected = initials === selectedAnalyst ? 'selected' : '';
                options += `<option value="${initials}" ${isSelected}>${initials}</option>`;
            });
            return options;
            }

            async function getStandardOptions(selectedStandard) {
            const standards = JSON.parse = await localforage.getItem("standards") || [];
            let options = '<option value="">Select Standard</option>'; // Default option

            standards.forEach(standard => {
                const isSelected = standard.id === selectedStandard ? 'selected' : '';
                options += `<option value="${standard.id}" ${isSelected}>${standard.id}</option>`;
            });

            return options;
        }

            async function getQualifierOptions(selectedQualifier) {
            const qualifiers = JSON.parse = await localforage.getItem('qualifiers') || [];
            let options = '<option value="">Select Qualifier</option>';
            qualifiers.forEach(qualifier => {
                const isSelected = qualifier.qualifierCode === selectedQualifier ? 'selected' : '';
                options += `<option value="${qualifier.qualifierCode}" ${isSelected}>${qualifier.qualifierCode}</option>`;
            });
            return options;
        }

            // Add event listener for expansion
            const expandBtn = mainRow.querySelector(".expand-btn");
            expandBtn.addEventListener("click", function () {
                toggleAnalyteRows(sample.id);
            });
        });

        // Handle "Save" button click
        document.getElementById("save-results-button").addEventListener("click", async function () {
    const updatedResults = {};

    // Loop through the associated samples and save their values
    associatedSamples.forEach(sample => {
        updatedResults[sample.id] = {
            analyst: document.querySelector(`select[name="analyst-${sample.id}"]`)?.value || "",
            instrument: document.querySelector(`select[name="instrument-${sample.id}"]`)?.value || "",
            runDate: document.querySelector(`input[name="run-date-${sample.id}"]`)?.value || "",
            spiked: document.querySelector(`select[name="spiked-${sample.id}"]`)?.value === "Yes",  // Convert to boolean
            dilutedFirst: document.querySelector(`select[name="diluted-first-${sample.id}"]`)?.value === "Yes",  // Convert to boolean
            standard: document.querySelector(`select[name="standard-id-${sample.id}"]`)?.value || "",  // Correct selector
            spikedAmount: document.querySelector(`input[name="spiked-amount-${sample.id}"]`)?.value || "",
            spikedUnits: document.querySelector(`input[name="spiked-units-${sample.id}"]`)?.value || "",
            comments: document.querySelector(`input[name="sample-comments-${sample.id}"]`)?.value || "",
            analytes: []
        };

        // Save data for each analyte in this sample
        const analytes = sample.analytes || [];
        analytes.forEach((analyte, index) => {
            updatedResults[sample.id].analytes.push({
                condition: document.querySelector(`select[name="condition-${sample.id}-${index}"]`)?.value || "",
                result: document.querySelector(`input[name="result-${sample.id}-${index}"]`)?.value || "",
                units: document.querySelector(`input[name="units-${sample.id}-${index}"]`)?.value || "",
                mdl: document.querySelector(`input[name="mdl-${sample.id}-${index}"]`)?.value || "",
                loq: document.querySelector(`input[name="loq-${sample.id}-${index}"]`)?.value || "",
                initialVolume: document.querySelector(`input[name="initial-volume-${sample.id}-${index}"]`)?.value || "",
                finalVolume: document.querySelector(`input[name="final-volume-${sample.id}-${index}"]`)?.value || "",
                dilution: document.querySelector(`input[name="dilution-${sample.id}-${index}"]`)?.value || "",
                qualifier: document.querySelector(`select[name="qualifier-${sample.id}-${index}"]`)?.value || "",
                comments: document.querySelector(`input[name="comments-${sample.id}-${index}"]`)?.value || ""
            });
        });
    });

    // Save the updated results to localStorage
    const savedResultsKey = `savedBatchResults-${batchId}`;
    await localforage.setItem(savedResultsKey, JSON.stringify(updatedResults));

    alert("Results have been saved successfully!");
});

        // Handle "Submit Results" button click
        document.getElementById("submit-results-button").addEventListener("click", async function () {
            batch.status = "In review";
            await localforage.setItem("batches", JSON.stringify(batches));
            alert("Batch status updated to 'In review'!");
            window.location.href = "batches.html";
        });

        document.getElementById("complete-review-button").addEventListener("click", async function() {
                    batch.status = "Complete";
                    await localforage.setItem("batches", JSON.stringify(batches));
                    document.getElementById("status").textContent = "Complete";
                    alert("Batch status updated to 'Complete'!");
                });

    } else {
        alert("Batch not found!");
        window.location.href = "batches.html";
    }
};

// Function to toggle analyte rows
async function toggleAnalyteRows(sampleId) {
    const analyteRows = document.querySelectorAll(`.analyte-row-${sampleId}`);
    const subRowHeader = document.querySelector(`.sub-header-${sampleId}`);
    const repeatedHeaderRow = document.querySelector(`.header-row-${sampleId}`);

    const isHidden = analyteRows[0]?.style.display === "none";

    // Toggle rows and header
    analyteRows.forEach(row => {
        row.style.display = isHidden ? "table-row" : "none";
    });

    if (subRowHeader) {
        subRowHeader.style.display = isHidden ? "table-row" : "none";
    }

    if (repeatedHeaderRow) {
        repeatedHeaderRow.style.display = isHidden ? "table-row" : "none";
    }

    // Toggle the triangle direction
    const expandBtn = document.querySelector(`.expand-btn[data-sample-id="${sampleId}"]`);
    expandBtn.textContent = expandBtn.textContent === "‚ñ∂" ? "‚ñº" : "‚ñ∂";
}
    </script>

    <script>
        document.addEventListener("keydown", function (event) {
    // Check if "Ctrl+D" is pressed
    if (event.ctrlKey && event.key.toLowerCase() === "d") {
        const activeElement = document.activeElement;

        // Ensure the active element is an input or select element
        if (activeElement && (activeElement.tagName === "INPUT" || activeElement.tagName === "SELECT")) {
            const cell = activeElement.closest("td");
            const row = activeElement.closest("tr"); // Get the row containing the element
            const table = activeElement.closest("table");

            if (row && cell) {
                const columnIndex = Array.from(cell.parentElement.children).indexOf(cell);
                const valueToFill = activeElement.value; // Get the value to fill

                if (row.classList.contains("sample-row")) {
                    // Autofill only in main rows
                    const mainRows = table.querySelectorAll(".sample-row");
                    mainRows.forEach(mainRow => {
                        const element = mainRow.children[columnIndex]?.querySelector("input, select");
                        if (element && element !== activeElement) {
                            element.value = valueToFill; // Autofill the value
                        }
                    });
                } else if (row.classList.contains("analyte-row")) {
                    // Autofill only in sub-rows
                    const analyteRows = table.querySelectorAll(".analyte-row");
                    analyteRows.forEach(analyteRow => {
                        const element = analyteRow.children[columnIndex]?.querySelector("input, select");
                        if (element && element !== activeElement) {
                            element.value = valueToFill; // Autofill the value
                        }
                    });
                }

                // Prevent the default behavior of "Ctrl+D"
                event.preventDefault();
            }
        }
    }
});
    </script>

<script>
    document.getElementById("view-qc").addEventListener("click", async function () {
        const urlParams = new URLSearchParams(window.location.search);
        const batchId = urlParams.get("batchId");

        if (!batchId) {
            alert("Batch ID is missing!");
            return;
        }

        // Retrieve necessary data from localStorage
        const samples = JSON.parse = await localforage.getItem("sampleDataArray") || [];
        const standards = JSON.parse = await localforage.getItem("standards") || []; // Standards data
        const associatedSamples = samples.filter(sample => sample.batchId === batchId && sample.sampleType !== "SAM");
        const savedResultsKey = `savedBatchResults-${batchId}`;
        const savedResults = JSON.parse = await localforage.getItem(savedResultsKey) || {};
        const testCodes = JSON.parse = await localforage.getItem("testCodes") || [];
        const batch = (JSON.parse = await localforage.getItem("batches")) || [].find(b => b.batchId === batchId);
        const matchedTestCode = testCodes.find(tc => tc.analysisId === batch.analysis);

        // Create analyte details map based on test code
        let analyteDetailsMap = {};
        if (matchedTestCode) {
            const matchedDetails = testCodes.find(tc => tc.uniqueId === matchedTestCode.uniqueId);
            if (matchedDetails && matchedDetails.analytes) {
                matchedDetails.analytes.forEach(analyte => {
                    analyteDetailsMap[analyte.analyteName] = {
                        units: analyte.units || "",
                        initialVolume: analyte.initialVolume || "",
                        finalVolume: analyte.finalVolume || "",
                        mdl: "",
                        loq: "",
                        lowerLimit: "",
                        upperLimit: "",
                        precision: ""
                    };
                });

                // Add QC data for control limits
                matchedDetails.qcTabs.forEach(tab => {
                    tab.rows.forEach(row => {
                        if (analyteDetailsMap[row.analyteName]) {
                            if (tab.tabName === "Method Blank") {
                                analyteDetailsMap[row.analyteName].mdl = row.mdl || "";
                                analyteDetailsMap[row.analyteName].loq = row.loq || "";
                            } else if (tab.tabName === "Laboratory Control Sample") {
                                analyteDetailsMap[row.analyteName].lowerLimit = row.lowerLimit || "";
                                analyteDetailsMap[row.analyteName].upperLimit = row.upperLimit || "";
                            } else if (tab.tabName === "Certified Reference Material") {
                                analyteDetailsMap[row.analyteName].lowerLimit = row.lowerLimit || "";
                                analyteDetailsMap[row.analyteName].upperLimit = row.upperLimit || "";
                            } else if (tab.tabName === "Matrix Spike") {
                                analyteDetailsMap[row.analyteName].lowerLimit = row.lowerLimit || "";
                                analyteDetailsMap[row.analyteName].upperLimit = row.upperLimit || "";
                            } else if (tab.tabName === "Laboratory Control Sample Duplicate") {
                                analyteDetailsMap[row.analyteName].lowerLimit = row.lowerLimit || "";
                                analyteDetailsMap[row.analyteName].upperLimit = row.upperLimit || "";
                                analyteDetailsMap[row.analyteName].precision = row.precision || "";
                            } else if (tab.tabName === "Matrix Spike Duplicate") {
                                analyteDetailsMap[row.analyteName].lowerLimit = row.lowerLimit || "";
                                analyteDetailsMap[row.analyteName].upperLimit = row.upperLimit || "";
                                analyteDetailsMap[row.analyteName].precision = row.precision || "";
                            } else if (tab.tabName === "Sample Duplicate") {
                                analyteDetailsMap[row.analyteName].lowerLimit = row.lowerLimit || "";
                                analyteDetailsMap[row.analyteName].upperLimit = row.upperLimit || "";
                                analyteDetailsMap[row.analyteName].precision = row.precision || "";
                            }
                        }
                    });
                });
            }
        }

        // Populate modal table
        const modalTable = document.querySelector("#qc-results-modal-table");
        const modalTableBody = modalTable.querySelector("tbody");
        modalTableBody.innerHTML = "";  // Clear previous content

        // Populate each sample's row with a repeated header
        associatedSamples.forEach(sample => {
            const relevantControls = getRelevantControlsForSampleType(sample.sampleType, analyteDetailsMap);

            // Insert a repeated header row above each sample row
            const repeatedHeaderRow = document.createElement("tr");
            repeatedHeaderRow.classList.add("repeated-header-row");
            repeatedHeaderRow.innerHTML = `
                <th></th> <!-- Expansion button column -->
                <th>Sample ID</th>
                <th>Sample Type</th>
                <th>Analyst</th>
                <th>Instrument</th>
                <th>Run Date</th>
                <th>Spiked?</th>
                <th>Diluted First?</th>
                <th>Standard ID</th>
                <th>Spiked Volume</th>
                <th>Spiked Units</th>
                <th>Comments</th>
            `;
            modalTableBody.appendChild(repeatedHeaderRow);

            // Main sample row
            const sampleResults = savedResults[sample.id] || {};
            const sampleRow = document.createElement("tr");
            sampleRow.classList.add("sample-row");
            sampleRow.innerHTML = `
                <td><button class="expand-btn" data-sample-id="${sample.id}">‚ñ∂</button></td>
                <td><a href="sample-details.html?id=${sample.id}">${sample.id}</a></td>
                <td>${sample.sampleType}</td>
                <td>${sampleResults.analyst || "N/A"}</td>
                <td>${sampleResults.instrument || "N/A"}</td>
                <td>${sampleResults.runDate || "N/A"}</td>
                <td>${sampleResults.spiked ? "Yes" : "No"}</td>
                <td>${sampleResults.dilutedFirst ? "Yes" : "No"}</td>
                <td>${sampleResults.standard || "N/A"}</td>
                <td>${sampleResults.spikedAmount || "N/A"}</td>
                <td>${sampleResults.spikedUnits || "N/A"}</td>
                <td>${sampleResults.comments || "N/A"}</td>
            `;
            modalTableBody.appendChild(sampleRow);

            // Fetch the Standard concentration for the selected standard
            const standard = standards.find(std => std.id === sampleResults.standard);
            const standardAnalyteConcentrations = standard ? Object.fromEntries(
                standard.analytes.map(analyte => [analyte.analyte, analyte.concentration])
            ) : {};

            // Sub-row header (dynamic based on relevant controls)
            const subRowHeader = document.createElement("tr");
            subRowHeader.classList.add("sub-row-header");
            subRowHeader.style.display = "none";

            // Always add the common headers
            let headerHTML = `<td></td><td>Analyte</td><td>Raw Result</td><td>Units</td><td>I-Vol</td><td>F-Vol</td><td>Post Prep Dil</td><td>Total Dil</td><td>Final Result</td><td>MDL Calc</td><td>LOQ Calc</td>`;
            relevantControls.forEach(control => {
                headerHTML += `<td>${control}</td>`;
            });

            // Conditionally add the "Standard Concentration", "Actual Concentration", and "% Recovery" headers
            if (sampleResults.standard) {
                headerHTML += `<td>Stock Std Conc</td><td>Dil Std Conc</td><td>% Rec</td><td>% RPD</td>`;
            }

            subRowHeader.innerHTML = headerHTML;
            modalTableBody.appendChild(subRowHeader);

            // Add analyte sub-rows
            const analytes = sample.analytes || [];
            analytes.forEach((analyte, index) => {
                const analyteResult = sampleResults.analytes?.[index] || {};
                const analyteInfo = analyteDetailsMap[analyte] || {};
                const standardConcentration = sampleResults.standard ? standardAnalyteConcentrations[analyte] || "N/A" : "";

                // Calculate Total Dilution
                let totalDilution = "N/A";
                if (analyteResult.initialVolume && analyteResult.finalVolume && analyteResult.dilution) {
                    const initialVolume = parseFloat(analyteResult.initialVolume);
                    const finalVolume = parseFloat(analyteResult.finalVolume);
                    const dilution = parseFloat(analyteResult.dilution);

                    if (!isNaN(initialVolume) && !isNaN(finalVolume) && !isNaN(dilution) && initialVolume > 0) {
                        totalDilution = (dilution * (finalVolume / initialVolume)).toFixed(0);
                    }
                }

                // Calculate final result
                let finalResult = "N/A";
                if (analyteResult.result && totalDilution !== "N/A") {
                    const resultValue = parseFloat(analyteResult.result);
                    const dilutionValue = parseFloat(totalDilution);

                    if (!isNaN(resultValue) && !isNaN(dilutionValue)) {
                        finalResult = (resultValue * dilutionValue).toFixed(2);
                    }
                }

                // Calculate mdl
                let mdlCalc = "N/A";
                if (analyteInfo.mdl && totalDilution !== "N/A") {
                    const mdlValue = parseFloat(analyteInfo.mdl);
                    const dilutionValue = parseFloat(totalDilution);

                    if (!isNaN(mdlValue) && !isNaN(dilutionValue)) {
                        mdlCalc = (mdlValue * dilutionValue).toFixed(2);
                    }
                }

                // Calculate loq
                let loqCalc = "N/A";
                if (analyteInfo.loq && totalDilution !== "N/A") {
                    const loqValue = parseFloat(analyteInfo.loq);
                    const dilutionValue = parseFloat(totalDilution);

                    if (!isNaN(loqValue) && !isNaN(dilutionValue)) {
                        loqCalc = (loqValue * dilutionValue).toFixed(2);
                    }
                }

                // Calculate actual concentration
                let actualConcentration = "N/A";
                if (standardConcentration !== "N/A" && sampleResults.spikedAmount && totalDilution) {
                    const spikedAmount = parseFloat(sampleResults.spikedAmount);
                    totalDilution = parseFloat(totalDilution);  // Remove 'const' to avoid re-declaring
                    const stdConcentration = parseFloat(standardConcentration);

                    if (!isNaN(spikedAmount) && !isNaN(totalDilution) && !isNaN(stdConcentration) && totalDilution > 0) {
                        actualConcentration = ((stdConcentration * spikedAmount) / totalDilution).toFixed(2);
                    }
                }

                // Calculate % recovery
                let percentRecovery = "N/A";
                let recoveryStyle = "";
                if (actualConcentration !== "N/A" && analyteResult.result) {
                    const resultValue = parseFloat(analyteResult.result);
                    const actualConcentrationValue = parseFloat(actualConcentration);

                    if (!isNaN(resultValue) && !isNaN(actualConcentrationValue) && actualConcentrationValue > 0) {
                        percentRecovery = ((resultValue / actualConcentrationValue) * 100).toFixed(2);

                        const lowerLimit = parseFloat(analyteInfo.lowerLimit);
                        const upperLimit = parseFloat(analyteInfo.upperLimit);

                        if (!isNaN(lowerLimit) && !isNaN(upperLimit)) {
                            if (percentRecovery >= lowerLimit && percentRecovery <= upperLimit) {
                                recoveryStyle = "color: #28a745; font-weight: bold;";  // Within limits
                            } else {
                                recoveryStyle = "color: #dc3545; font-weight: bold;";  // Outside limits
                            }
                        }
                    }
                }

                // Calculate % RPD
                let percentRPD = "N/A";
                let rpdStyle = "";
                if (sample.parent) {
                    const parentSample = samples.find(s => s.id === sample.parent);
                    if (parentSample) {
                        const parentAnalyteResult = (savedResults[parentSample.id]?.analytes?.[index] || {}).result || "N/A";
                        if (parentAnalyteResult !== "N/A" && analyteResult.result) {
                            const parentValue = parseFloat(parentAnalyteResult);
                            const currentValue = parseFloat(analyteResult.result);

                            if (!isNaN(parentValue) && !isNaN(currentValue) && parentValue > 0 && currentValue > 0) {
                                const average = (parentValue + currentValue) / 2;
                                const difference = Math.abs(parentValue - currentValue);
                                percentRPD = ((difference / average) * 100).toFixed(2);

                                const precision = parseFloat(analyteInfo.precision);
                                if (!isNaN(precision)) {
                                    if (Math.abs(percentRPD) <= precision) {
                                        rpdStyle = "color: #28a745; font-weight: bold;";  // Within limits
                                    } else {
                                        rpdStyle = "color: #dc3545; font-weight: bold;";  // Outside limits
                                    }
                                }
                            }
                        }
                    }
                }

                // Determine status icon for method blank based on MDL and LOQ
                let statusIcon = "";
                if (sample.sampleType === "MB" && analyteResult.result) {
                    const resultValue = parseFloat(analyteResult.result);
                    const mdlValue = parseFloat(analyteInfo.mdl);
                    const loqValue = parseFloat(analyteInfo.loq);

                    if (!isNaN(resultValue) && !isNaN(mdlValue) && !isNaN(loqValue)) {
                        if (resultValue < mdlValue && resultValue < loqValue) {
                            statusIcon = "‚úÖ";  // Green check if less than both MDL and LOQ
                        } else if (resultValue >= mdlValue && resultValue < loqValue) {
                            statusIcon = "‚ö†Ô∏è";  // Orange caution if between MDL and LOQ
                        } else if (resultValue >= loqValue) {
                            statusIcon = "‚ùó";  // Red exclamation if greater than or equal to LOQ
                        }
                    }
                }

                // Default status icon logic for other sample types
                if (!statusIcon) {
                    if (recoveryStyle.includes("#dc3545") || rpdStyle.includes("#dc3545")) {
                        statusIcon = "‚ùó";
                    } else if (recoveryStyle.includes("#28a745") || rpdStyle.includes("#28a745")) {
                        statusIcon = "‚úÖ";
                    }
                }

                // Add analyte row
                const analyteRow = document.createElement("tr");
                analyteRow.classList.add("analyte-row", `analyte-row-${sample.id}`);
                analyteRow.style.display = "none";

                let rowHTML = `
                    <td>${statusIcon}</td>
                    <td>${analyte}</td>
                    <td>${analyteResult.result || "N/A"}</td>
                    <td>${analyteInfo.units || "N/A"}</td>
                    <td>${analyteResult.initialVolume || "N/A"}</td>
                    <td>${analyteResult.finalVolume || "N/A"}</td>
                    <td>${analyteResult.dilution || "N/A"}</td>
                    <td>${totalDilution}</td>
                    <td>${finalResult}</td>
                    <td>${mdlCalc}</td>
                    <td>${loqCalc}</td>
                `;

                relevantControls.forEach(control => {
                    rowHTML += `<td>${analyteInfo[control] || "N/A"}</td>`;
                });

                if (sampleResults.standard) {
                rowHTML += `
                    <td>${standardConcentration}</td>
                    <td>${actualConcentration !== "N/A" ? actualConcentration : "N/A"}</td>
                    <td style="${recoveryStyle}">${percentRecovery}</td>
                    <td style="${rpdStyle}">${percentRPD}</td>
                `;
    }

                analyteRow.innerHTML = rowHTML;
                modalTableBody.appendChild(analyteRow);
                
            });

            // Expand/collapse functionality
            sampleRow.querySelector(".expand-btn").addEventListener("click", async function () {
                const analyteRows = modalTableBody.querySelectorAll(`.analyte-row-${sample.id}`);
                const isHidden = analyteRows[0]?.style.display === "none";

                analyteRows.forEach(row => (row.style.display = isHidden ? "table-row" : "none"));
                subRowHeader.style.display = isHidden ? "table-row" : "none";
                this.textContent = isHidden ? "‚ñº" : "‚ñ∂";
            });
        });

        // Display the modal
        const modal = document.getElementById("qc-results-modal-table-container");
        modal.style.display = "block";

        // Close modal functionality
        document.getElementById('close-btn').addEventListener('click', async function () {
            document.getElementById('qc-results-modal-table-container').style.display = 'none';
        });

        // Close the modal when clicking outside the modal content
        window.addEventListener("click", async function (event) {
            if (event.target === modal) {
                modal.style.display = "none";
            }
        });

        async function getRelevantControlsForSampleType(sampleType, analyteDetails) {
            const controls = [];
            const analyteArray = Object.values(analyteDetails);

            if (sampleType === "MB") {
                if (analyteArray.some(analyte => analyte.mdl)) controls.push("mdl");
                if (analyteArray.some(analyte => analyte.loq)) controls.push("loq");
            } else if (sampleType === "LCS") {
                if (analyteArray.some(analyte => analyte.lowerLimit)) controls.push("lowerLimit");
                if (analyteArray.some(analyte => analyte.upperLimit)) controls.push("upperLimit");
            } else if (sampleType === "CRM") {
                if (analyteArray.some(analyte => analyte.lowerLimit)) controls.push("lowerLimit");
                if (analyteArray.some(analyte => analyte.upperLimit)) controls.push("upperLimit");
            } else if (sampleType === "MS") {
                if (analyteArray.some(analyte => analyte.lowerLimit)) controls.push("lowerLimit");
                if (analyteArray.some(analyte => analyte.upperLimit)) controls.push("upperLimit");
            } else if (sampleType === "LCSD") {
                if (analyteArray.some(analyte => analyte.lowerLimit)) controls.push("lowerLimit");
                if (analyteArray.some(analyte => analyte.upperLimit)) controls.push("upperLimit");
                if (analyteArray.some(analyte => analyte.precision)) controls.push("precision");
            } else if (sampleType === "MSD") {
                if (analyteArray.some(analyte => analyte.lowerLimit)) controls.push("lowerLimit");
                if (analyteArray.some(analyte => analyte.upperLimit)) controls.push("upperLimit");
                if (analyteArray.some(analyte => analyte.precision)) controls.push("precision");
            } else if (sampleType === "SAMDUP") {
                if (analyteArray.some(analyte => analyte.precision)) controls.push("precision");
            }

            return controls;
        }
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.4.0/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>



</body>
</html>



